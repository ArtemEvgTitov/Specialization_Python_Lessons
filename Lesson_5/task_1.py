# Начнём с классического обмена значений переменных.
a = 42
b = 73
a, b = b, a
print(f'{a=}\t{b=}')

# Рассмотрим другие варианты упаковки и распаковки значений.
a, b, c = input("Три символа: ")
print(f'{a=} {b=} {c=}')

# Как вы помните функция input возвращает строку str. Указав не одну переменную, а
# три мы распаковываем строку из 3-х символов в три отдельные переменные.

a, b, c = ("один", "два", "три",)
print(f'{a=} {b=} {c=}')

# Аналогичным образом можно распаковать кортеж из трёх элементов в три
# переменные. Со списком list, множеством set и прочими коллекциями будет
# работать аналогично

a, b, c = {"один", "два", "три", "четыре", "пять"}
print(f'{a=} {b=} {c=}') # ValueError: too many values to unpack (expected 3)


# Распаковка коллекции с упаковкой “лишнего”, упаковка со звёздочкой
# Для упаковки может применяться символ “звёздочка” перед именем переменной.
# Такая переменная превратиться в список и соберёт в себя все значения, не
# поместившиеся в остальные переменные

data = ["один", "два", "три", "четыре", "пять", "шесть", "семь",
]
a, b, c, *d = data
print(f'{a=} {b=} {c=} {d=}')
a, b, *c, d = data
print(f'{a=} {b=} {c=} {d=}')
a, *b, c, d = data
print(f'{a=} {b=} {c=} {d=}')
*a, b, c, d = data
print(f'{a=} {b=} {c=} {d=}')

# Если нам нужна часть данных в переменных, а упакованный список в дальнейших
# расчётах не участвует, в качестве переменной используют подчеркивание

link ='https://docs.python.org/3/faq/programming.html#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another'
prefix, *_, suffix = link.split('/')

# Ещё один способ применения звёздочки — распаковка элементов коллекции.
# Длинный вариант вывода элементов последовательности в одну строку с
# разделителем табуляцией:

data = [2, 4, 6, 8, 10, ]
for item in data:
    print(item, end='\t')

# И аналогичная операция в одну строку с распаковкой:

data = [2, 4, 6, 8, 10, ]
print(*data, sep='\t')

# Если несколько переменных должны получить одинаковые значение, можно
# объединить несколько строк в одну.

a = b = c = 0
a += 42
print(f'{a=} {b=} {c=}')

# Подобная запись допустима только с неизменяемыми типами данных. В противном
# случае изменение одной переменной приведёт к изменению и других.

a = b = c = {1, 2, 3}
a.add(42)
print(f'{a=} {b=} {c=}')

# Другой вариант множественного присваивания похож на обмен переменных
# местами.

a, b, c = 1, 2, 3
print(f'{a=} {b=} {c=}')

# А если в левой части указать лишь одну переменную, получим кортеж.

t = 1, 2, 3
print(f'{t=}, {type(t)}')

# Аналогично присваиванию можно сравнить несколько переменных внутри
# конструкции if.

a = b = c = 42
# if a == b and b == c:
if a == b == c:
    print('Полное совпадение')

# Запись становится короче, т.к. исключается команда and внутри сравнения.
# Работает подобная запись не только с проверкой на равенство, но и с другими
# операциями.

if a < b < c:
    print('b больше a и меньше c')

# А теперь несколько примеров плохого кода. Да, он будет работать, т.к. Python
# прощает ошибки. Но читать такой код будет сложно. И есть большая вероятность,
# что коллеги по проекту не простят подобный код

a = 12; b = 42; c = 73
if a < b < c: b = None; print('Ужасный код')

